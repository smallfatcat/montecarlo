---
description: Rules for Monte Carlo casino app (blackjack simulations, poker, performance, architecture)
globs: ["src/**", "vite-app/**", "apps/**", "packages/**", "scripts/**"]
alwaysApply: false
---
# Monte Carlo Monorepo Rules

## Scope & Structure
- Monorepo with npm workspaces: `vite-app/` (frontend), `apps/game-server/` (backend), `packages/*` (shared libs and engines), `docs/`.
- Do not edit generated artifacts: `**/dist/**`, `vite-app/BUILD_INFO`, `vite-app/VERSION`, repository `BUILD_INFO`.
- Prefer absolute imports with workspace-relative paths; exports live in each package's `index.ts`.

## Language & Tooling
- TypeScript everywhere (ES2020+). Enable `strict` in all `tsconfig`s; no `any` in exported APIs.
- ESM modules across repo. Node targets Node 18+.
- Lint with ESLint TypeScript rules; run `npm run lint` before commit. Keep code formatting consistent with existing files.
- Type-check with `npm run typecheck` in repo root.

## Frontend (React 19 + Vite: `vite-app/`)
- Components use functional React with hooks. Prefer composition over inheritance.
- State management:
  - Global/shared UI state uses Zustand stores in `vite-app/src/stores/`.
  - Use selector hooks (`useStore(state => state.slice)`) to minimize re-renders.
  - Do not manage shared state with `useState` inside components.
- Web Workers for heavy work (Monte Carlo, odds, shuffling simulations):
  - Place under `vite-app/src/workers/`.
  - Message contracts are typed in `packages/shared` and imported in both worker and UI.
  - Workers must be pure/deterministic and never touch DOM or global singletons.
  - Chunk long-running tasks and post periodic progress updates.
- UI performance: avoid blocking main thread; memoize expensive components; virtualize large lists; debounce inputs.
- Testing: Vitest + React Testing Library; prefer user-centric tests. Co-locate tests as `*.test.tsx`.

## Backend (Fastify + Socket.IO: `apps/game-server/`)
- Keep the server I/O layer thin; delegate game rules to `packages/*` engines.
- Validate all inputs:
  - Fastify JSON schema or Zod (compiled at startup). Reject on invalid payloads.
  - Normalize and type responses; never emit untyped payloads.
- WebSocket events:
  - Name as `domain:action` (e.g., `lobby:update`, `table:join-request`).
  - Event payload types are defined in `packages/shared` and imported on server and client.
- Do not block the event loop. Offload CPU tasks to Workers or child processes, or precompute in packages when feasible.

## Packages
- `packages/poker-engine` and any blackjack engine code are pure and deterministic:
  - No side effects, timers, randomness without seeded RNG injected via parameters.
  - Functions return new values; never mutate inputs.
- `packages/shared` holds cross-app types, message contracts, and utilities used by both server and client. No app-specific logic here.
- Avoid circular dependencies across packages. Only import from package public exports.

## Monte Carlo & Simulations
- Implement simulations as pure function runners invoked from Workers.
- Accept configuration objects; return structured results and summary statistics.
- Process in batches to keep UIs responsive; expose progress percentage and ETA.
- Use transferable objects or structured clones for large result sets; avoid retaining large arrays.
- Provide a UI control in the frontend to enable/disable high-speed mode for simulations.

## Game Rules & Determinism
- Engines (poker, blackjack) must be reproducible given the same seed and inputs.
- Encapsulate house rules in config objects; validate before execution.
- Add guard clauses for invalid state transitions; never proceed with inconsistent state.

## Error Handling & Logging
- Throw domain-specific errors with machine-readable codes and user-friendly messages.
- Server: log errors with context (tableId, playerId) and stack traces; avoid leaking internals to clients.
- Client: surface actionable toasts/messages; fail soft and keep UI interactive.

## Testing
- Unit tests for all exported engine functions and reducers/selectors in stores. Target >=80% coverage for packages and critical UI logic.
- Integration tests for lobby and table flows, including WebSocket interactions (happy paths and failures).
- Basic performance tests for simulation throughput and memory usage on representative inputs.

## Performance Guidelines
- Prefer data-oriented structures over deep object graphs in hot paths.
- Minimize allocations in tight loops; reuse buffers when safe.
- Memoize computed values and cache expensive pure computations.

## Accessibility & UX
- Aim for WCAG 2.1 AA. Ensure keyboard navigability, ARIA roles, and sufficient contrast.
- Live regions for critical updates; avoid motion that impacts readability.

## Build & Workflow
- Use the workspace scripts in `package.json`:
  - Dev: `npm run dev:all` (or per app)
  - Build: `npm run build:all` then `npm run postbuild:all` for version files
  - Tests: `npm run test:all`
- Do not modify version files by hand; they are generated.
- Commit messages: `type(scope): description` where scope âˆˆ `blackjack|poker|ui|engine|simulation|server|shared`.

## Code Review Checklist
- Types are explicit on public APIs; no `any` leaks.
- Engines are pure and deterministic; no hidden state.
- Workers used for CPU-heavy tasks; UI remains responsive.
- Input validation present on server routes and events.
- Tests added/updated; performance implications considered.
- No direct imports across apps/packages beyond public exports.
